<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Virtual Fish Tank</title>
    <style>
        /* Basic styles to make the canvas fill the entire screen */
        body {
            margin: 0;
            padding: 0;
            overflow: hidden; /* Prevents scrollbars */
            background-color: #000; /* Fallback color */
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block; /* Removes any default spacing below the canvas */
            cursor: pointer;
        }
        /* Styles for the settings panel */
        #settingsPanel {
            position: absolute;
            top: 60px;
            left: 20px;
            background-color: rgba(0, 0, 0, 0.75);
            color: white;
            padding: 20px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            display: none; /* Initially hidden */
            width: 250px;
        }
        #settingsPanel.visible {
            display: block;
        }
        #settingsPanel h3 {
            margin-top: 0;
            text-align: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
        #settingsPanel label {
            display: block;
            margin-bottom: 8px;
        }
        #settingsPanel input[type="text"],
        #settingsPanel input[type="range"] {
            width: 100%;
            padding: 8px;
            box-sizing: border-box;
            border-radius: 5px;
            border: 1px solid #555;
            background-color: #333;
            color: white;
        }
        #settingsPanel input[type="range"] {
            padding: 0;
            margin-top: 5px;
        }
        #settingsPanel .volume-display {
            text-align: center;
            font-size: 0.9em;
            margin-bottom: 20px;
        }
        #settingsPanel button {
            width: 100%;
            padding: 10px;
            background-color: #0077be;
            border: none;
            color: white;
            font-size: 1em;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        #settingsPanel button:hover {
            background-color: #005d9c;
        }
    </style>
</head>
<body>
    <canvas id="fishTankCanvas"></canvas>

    <!-- Settings Panel HTML --><div id="settingsPanel">
        <h3>Settings</h3>
        <label for="fishNameInput">Fish Name:</label>
        <input type="text" id="fishNameInput" maxlength="15" placeholder="Enter a name">
        
        <label for="volumeSlider" style="margin-top: 20px;">Volume:</label>
        <input type="range" id="volumeSlider" min="0" max="10" value="5">
        <div class="volume-display" id="volumeValue">5</div>

        <button id="saveSettingsBtn">Save</button>
    </div>

    <script>
        // --- Canvas and Context Setup ---
        const canvas = document.getElementById('fishTankCanvas');
        const ctx = canvas.getContext('2d');

        // --- Settings Panel DOM Elements ---
        const settingsPanel = document.getElementById('settingsPanel');
        const fishNameInput = document.getElementById('fishNameInput');
        const volumeSlider = document.getElementById('volumeSlider');
        const volumeValue = document.getElementById('volumeValue');
        const saveSettingsBtn = document.getElementById('saveSettingsBtn');
        let isSettingsOpen = false;

        // Set initial canvas size
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Adjust canvas size when the browser window is resized
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });


        // --- Background Audio Setup ---
        const bgMusic = new Audio('https://onx.wdfiles.com/local--files/fishtank/JoelFazhari-aquarium-ambience-sounds-10-min-193236.mp3');
        bgMusic.loop = true;
        bgMusic.volume = 0.5; // Default volume

        // A function to start the audio, called on the first user interaction to comply with autoplay policies.
        function startAudio() {
            const playPromise = bgMusic.play();
            if (playPromise !== undefined) {
                playPromise.catch(error => {
                    console.error("Audio playback failed:", error);
                });
            }
            window.removeEventListener('mousedown', startAudio);
            window.removeEventListener('touchstart', startAudio);
        }

        // Listen for the first click or touch to start the audio.
        window.addEventListener('mousedown', startAudio);
        window.addEventListener('touchstart', startAudio);
        
        // --- Cookie Helper Functions ---
        function setCookie(name, value, days) {
            let expires = "";
            if (days) {
                const date = new Date();
                date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
                expires = "; expires=" + date.toUTCString();
            }
            document.cookie = name + "=" + (value || "") + expires + "; path=/; SameSite=Lax";
        }

        function getCookie(name) {
            const nameEQ = name + "=";
            const ca = document.cookie.split(';');
            for (let i = 0; i < ca.length; i++) {
                let c = ca[i];
                while (c.charAt(0) == ' ') c = c.substring(1, c.length);
                if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length, c.length);
            }
            return null;
        }

        // --- Fish Data Persistence ---
        function saveFishData() {
            const data = {
                name: fish.name,
                foodEaten: fish.foodEaten,
                volume: bgMusic.volume
            };
            setCookie('fishData', JSON.stringify(data), 3650);
        }

        function loadFishData() {
            const savedData = getCookie('fishData');
            if (savedData) {
                try {
                    const data = JSON.parse(savedData);
                    fish.name = data.name || assignNewFishName();
                    fish.foodEaten = data.foodEaten || 0;
                    bgMusic.volume = (typeof data.volume === 'number') ? data.volume : 0.5;
                } catch (e) {
                    console.error("Could not parse fish data from cookie, starting fresh.", e);
                    assignNewFish();
                }
            } else {
                assignNewFish();
            }
        }
        
        function assignNewFishName() {
            const fishNames = ["Finley", "Goldie", "Bubbles", "Captain", "Coral", "Nemo", "Skipper", "Sunny", "Splash", "Wanda"];
            return fishNames[Math.floor(Math.random() * fishNames.length)];
        }

        function assignNewFish() {
            fish.name = assignNewFishName();
            fish.foodEaten = 0;
            bgMusic.volume = 0.5;
            saveFishData(); // Save the newly created fish data right away
        }


        // --- Fish Object ---
        const fish = {
            name: '', 
            foodEaten: 0, 
            x: canvas.width / 2,
            y: canvas.height / 2,
            size: 20,
            speed: 1,
            originalSpeed: 1, 
            color: '#ff8c00', 
            direction: 1, 
            angle: 0, 
            currentAngle: 0, 
            state: 'swimming', 
            pauseTimer: 0,
            pupilOffsetX: 0,
            pupilOffsetY: 0,
            pupilTargetX: 0,
            pupilTargetY: 0,
            pupilTimer: 120,
            target: { x: Math.random() * canvas.width, y: Math.random() * (canvas.height - 200) + 50 },

            draw: function() {
                ctx.save(); 
                ctx.translate(this.x, this.y); 
                ctx.scale(this.direction, 1); 
                ctx.rotate(this.currentAngle); 
                ctx.fillStyle = this.color;
                
                // Body
                ctx.beginPath();
                ctx.moveTo(0, 0); 
                ctx.quadraticCurveTo(-this.size * 0.7, -this.size * 0.9, -this.size * 1.5, 0);
                ctx.quadraticCurveTo(-this.size * 0.7, this.size * 0.9, 0, 0);
                ctx.fill();

                // Tail
                ctx.beginPath();
                ctx.moveTo(-this.size * 1.5, 0);
                ctx.lineTo(-this.size * 2, -this.size * 0.5);
                ctx.lineTo(-this.size * 2, this.size * 0.5);
                ctx.closePath();
                ctx.fill();

                // Fin
                ctx.fillStyle = '#cc6600'; 
                ctx.beginPath();
                const finTopY = -this.size * 0.3; 
                const finBackX = -this.size * 1.0; 
                const finSwayAmount = Math.sin(Date.now() * 0.005) * this.size * 0.05; 
                ctx.moveTo(finBackX, finTopY); 
                ctx.quadraticCurveTo(
                    finBackX + this.size * 0.4 + finSwayAmount, 
                    finTopY + this.size * 0.2, 
                    finBackX, 
                    finTopY + this.size * 0.6 
                );
                ctx.closePath();
                ctx.fill();


                // Eye - white with black stroke and pupil
                const eyeRadius = this.size * 0.2; 
                const pupilRadius = this.size * 0.1; 

                // White part of the eye
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(-this.size * 0.3, -this.size * 0.15, eyeRadius, 0, Math.PI * 2);
                ctx.fill();

                // Black stroke around the eye
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(-this.size * 0.3, -this.size * 0.15, eyeRadius, 0, Math.PI * 2);
                ctx.stroke();

                // Black pupil with animated offset
                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(-this.size * 0.3 + this.pupilOffsetX, -this.size * 0.15 + this.pupilOffsetY, pupilRadius, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore(); 
            },

            update: function() {
                // --- State Transition Logic ---
                if (foodBubble.active && this.state !== 'eating' && foodBubble.y < canvas.height - 120) {
                    this.state = 'eating';
                    this.target = foodBubble;
                    this.speed = this.originalSpeed * 2;
                } 
                else if (this.state === 'eating' && !foodBubble.active) {
                    this.speed = this.originalSpeed;
                    this.setNewTarget();
                }

                // --- Handle Actions Based on State ---
                if (this.state === 'pausing' || this.state === 'inspecting') {
                    this.pauseTimer--;
                    this.angle = 0;
                    if (this.pauseTimer <= 0) {
                        this.setNewTarget();
                    }
                } else { // Handle movement for 'swimming', 'investigating', 'eating'
                    const currentTarget = this.state === 'eating' ? foodBubble : this.target;
                    const dx = currentTarget.x - this.x;
                    const dy = currentTarget.y - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < this.size + 5) { // Arrived at target
                        this.angle = 0; 
                        if (this.state === 'eating') {
                            foodBubble.active = false;
                            this.foodEaten++;
                            saveFishData();
                            this.speed = this.originalSpeed;
                            this.setNewTarget();
                        } else if (this.state === 'investigating') {
                            this.state = 'inspecting';
                            this.pauseTimer = Math.random() * 180 + 180; // Inspect for 2-4 seconds
                        } else { // Arrived at a normal swimming target
                            if (Math.random() < 0.2) { // Increased chance to investigate
                                this.setInvestigationTarget();
                            } else if (Math.random() < 0.1) { // Chance to just pause
                                this.state = 'pausing';
                                this.pauseTimer = Math.random() * 180 + 60;
                            } else {
                                this.setNewTarget();
                            }
                        }
                    } else { // Move towards target
                        this.x += (dx / distance) * this.speed;
                        this.y += (dy / distance) * this.speed;
                        this.direction = (dx > 0) ? 1 : -1;

                        let targetAngle = Math.atan2(dy, this.direction * dx);
                        const angleThreshold = 10 * (Math.PI / 180);
                        this.angle = (Math.abs(targetAngle) < angleThreshold) ? 0 : targetAngle;
                    }
                }
                
                // Smoothly update the current drawing angle
                this.currentAngle += (this.angle - this.currentAngle) * 0.1;

                // --- Pupil Animation Logic ---
                this.pupilTimer--;
                if (this.pupilTimer <= 0) {
                    const maxOffset = this.size * 0.1; // eyeRadius - pupilRadius
                    if (this.pupilTargetX === 0 && this.pupilTargetY === 0) { // If pupil is centered...
                        if (this.state === 'inspecting') {
                            // Look towards the object of interest (forward)
                            this.pupilTargetX = (Math.random() * 0.5 + 0.4) * maxOffset;
                            this.pupilTargetY = (Math.random() * 2 - 1) * maxOffset * 0.7; // Less vertical movement
                        } else { // Look randomly
                            this.pupilTargetX = (Math.random() * 2 - 1) * maxOffset;
                            this.pupilTargetY = (Math.random() * 2 - 1) * maxOffset;
                        }
                        this.pupilTimer = Math.random() * 60 + 60; // Hold look for 1-2s
                    } else { // If pupil is looking somewhere, reset it to center
                        this.pupilTargetX = 0;
                        this.pupilTargetY = 0;
                        // Set delay for next look (more frequent if paused/inspecting)
                        const baseDelay = (this.state === 'pausing' || this.state === 'inspecting') ? 45 : 180;
                        this.pupilTimer = Math.random() * 120 + baseDelay;
                    }
                }
                // Smoothly move the pupil towards its target
                this.pupilOffsetX += (this.pupilTargetX - this.pupilOffsetX) * 0.08;
                this.pupilOffsetY += (this.pupilTargetY - this.pupilOffsetY) * 0.08;
            },
            
            setNewTarget: function() {
                this.state = 'swimming';
                const sandLevel = canvas.height - 100;
                // Expanded vertical swimming area to get closer to the sand
                this.target = {
                    x: Math.random() * (canvas.width - 100) + 50,
                    y: Math.random() * (sandLevel - 80) + 50 // y range is now from 50 to just above the sand
                };
            },

            setInvestigationTarget: function() {
                this.state = 'investigating';
                const pointsOfInterest = [
                    { x: canvas.width * 0.75, y: canvas.height - 150 }, // Castle
                    { x: canvas.width * 0.2, y: canvas.height - 120 }  // Treasure Chest
                ];
                this.target = pointsOfInterest[Math.floor(Math.random() * pointsOfInterest.length)];
            }
        };

        // --- Load existing fish data or create a new one ---
        loadFishData();


        // --- Food Bubble Object ---
        const foodBubble = {
            x: -100, y: -100, radius: 10, speed: 1, active: false,
            color: 'rgba(255, 255, 0, 0.7)', borderColor: 'rgba(255, 255, 0, 0.9)',
            spawn: function() {
                this.x = Math.random() * canvas.width;
                this.y = canvas.height - 90;
                this.radius = Math.random() * 8 + 6;
                this.speed = Math.random() * 0.5 + 0.8; 
                this.active = true;
            },
            draw: function() {
                if (!this.active) return;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.strokeStyle = this.borderColor;
                ctx.lineWidth = 2;
                ctx.fill();
                ctx.stroke();
            },
            update: function() {
                if (!this.active) return;
                this.y -= this.speed;
                if (this.y < -this.radius) this.active = false;
            }
        };
        
        // --- Food Bubble Spawning Logic ---
        function scheduleNextFoodBubble() {
            const delay = Math.random() * 120000 + 60000;
            setTimeout(() => {
                if (!foodBubble.active) foodBubble.spawn();
                scheduleNextFoodBubble();
            }, delay);
        }


        // --- Bubbles ---
        let bubbles = [];
        const numBubbles = 25;
        class Bubble {
            constructor() { this.reset(); this.y = Math.random() * canvas.height; }
            reset() {
                this.x = Math.random() * canvas.width;
                this.y = canvas.height + Math.random() * 100;
                this.radius = Math.random() * 5 + 1;
                this.speed = Math.random() * 1 + 0.5;
            }
            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.lineWidth = 1;
                ctx.fill();
                ctx.stroke();
            }
            update() { this.y -= this.speed; if (this.y < -this.radius) this.reset(); }
        }
        for (let i = 0; i < numBubbles; i++) bubbles.push(new Bubble());


        // --- Drawing Functions for Scenery ---
        
        function drawSettingsIcon(x, y, size) {
            const rotation = Date.now() / 1000 * 0.2; 
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(rotation);
            ctx.font = `${size}px Arial`;
            ctx.fillStyle = isSettingsOpen ? '#00c3ff' : 'rgba(255, 255, 255, 0.8)';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('⚙️', 0, 0); 
            ctx.restore();
        }

        const settingsIcon = { x: 30, y: 30, size: 25 };

        function drawUI() {
            drawSettingsIcon(settingsIcon.x, settingsIcon.y, settingsIcon.size);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.font = '22px Arial';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            const text = `${fish.name} | Food Eaten: ${fish.foodEaten}`;
            ctx.fillText(text, settingsIcon.x + 35, 20); 
        }

        function drawWater() {
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#0077be');
            gradient.addColorStop(1, '#003d7a');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        function drawSand() {
            ctx.fillStyle = '#d2b48c';
            ctx.beginPath();
            ctx.moveTo(0, canvas.height - 80);
            for (let i = 0; i < canvas.width; i++) {
                ctx.lineTo(i, canvas.height - 80 + Math.sin(i * 0.01) * 10);
            }
            ctx.lineTo(canvas.width, canvas.height);
            ctx.lineTo(0, canvas.height);
            ctx.closePath();
            ctx.fill();
        }

        function drawCastle() {
            ctx.fillStyle = '#8a8a8a'; ctx.strokeStyle = '#5a5a5a'; ctx.lineWidth = 3;
            const baseX = canvas.width * 0.75, baseY = canvas.height - 70;
            ctx.fillRect(baseX - 50, baseY - 100, 100, 100); ctx.strokeRect(baseX - 50, baseY - 100, 100, 100);
            ctx.beginPath(); ctx.moveTo(baseX - 60, baseY - 100);
            ctx.lineTo(baseX, baseY - 150); ctx.lineTo(baseX + 60, baseY - 100);
            ctx.closePath(); ctx.fill(); ctx.stroke();
            ctx.fillStyle = '#5a5a5a'; ctx.fillRect(baseX - 15, baseY - 30, 30, 30);
        }

        function drawTreasureChest() {
            const baseX = canvas.width * 0.2, baseY = canvas.height - 70;
            ctx.fillStyle = '#8B4513'; ctx.strokeStyle = '#5a2d0c'; ctx.lineWidth = 4;
            ctx.fillRect(baseX - 40, baseY - 30, 80, 40); ctx.strokeRect(baseX - 40, baseY - 30, 80, 40);
            ctx.beginPath(); ctx.moveTo(baseX - 40, baseY - 30);
            ctx.quadraticCurveTo(baseX, baseY - 70, baseX + 40, baseY - 30);
            ctx.closePath(); ctx.fill(); ctx.stroke();
        }

        function drawRocks() {
             ctx.fillStyle = '#696969'; ctx.strokeStyle = '#404040'; ctx.lineWidth = 2;
             ctx.beginPath(); ctx.moveTo(100, canvas.height - 70);
             ctx.quadraticCurveTo(120, canvas.height - 110, 150, canvas.height - 75);
             ctx.quadraticCurveTo(130, canvas.height - 50, 100, canvas.height - 70);
             ctx.fill(); ctx.stroke();
             ctx.beginPath(); ctx.moveTo(canvas.width - 150, canvas.height - 80);
             ctx.quadraticCurveTo(canvas.width - 130, canvas.height - 120, canvas.width - 100, canvas.height - 85);
             ctx.quadraticCurveTo(canvas.width - 120, canvas.height - 60, canvas.width - 150, canvas.height - 80);
             ctx.fill(); ctx.stroke();
        }

        function drawPlants() {
            ctx.strokeStyle = '#006400'; ctx.lineWidth = 4;
            drawSeaweed(canvas.width * 0.3, canvas.height - 70, 180, 20, 0.05);
            drawSeaweed(canvas.width * 0.3 + 20, canvas.height - 70, 160, 15, 0.06);
            drawSeaweed(canvas.width * 0.9, canvas.height - 70, 200, 25, -0.04);
        }
        
        function drawSeaweed(x, y, height, width, sway) {
            ctx.beginPath(); ctx.moveTo(x, y);
            for (let i = 0; i < height; i++) {
                let swayX = x + Math.sin(i * sway + Date.now() * 0.001) * (width * (1 - i/height));
                ctx.lineTo(swayX, y - i);
            }
            ctx.stroke();
        }

        // --- Settings Panel Logic ---
        function toggleSettingsPanel() {
            isSettingsOpen = !isSettingsOpen;
            if (isSettingsOpen) {
                fishNameInput.value = fish.name;
                volumeSlider.value = bgMusic.volume * 10;
                volumeValue.textContent = volumeSlider.value;
                settingsPanel.classList.add('visible');
            } else {
                settingsPanel.classList.remove('visible');
            }
        }

        canvas.addEventListener('click', (event) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;

            const dx = mouseX - settingsIcon.x;
            const dy = mouseY - settingsIcon.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < settingsIcon.size) { 
                toggleSettingsPanel();
            }
        });

        volumeSlider.addEventListener('input', () => {
            const newVolume = volumeSlider.value / 10;
            bgMusic.volume = newVolume;
            volumeValue.textContent = volumeSlider.value;
        });

        saveSettingsBtn.addEventListener('click', () => {
            const newName = fishNameInput.value.trim();
            if (newName) { 
                fish.name = newName.substring(0, 15);
            }
            saveFishData();
            toggleSettingsPanel(); 
        });


        // --- Main Animation Loop ---
        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawWater();
            drawSand();
            drawCastle();
            drawTreasureChest();
            drawRocks();
            drawPlants();

            if (foodBubble.active) {
                foodBubble.update();
                foodBubble.draw();
            }

            bubbles.forEach(bubble => {
                bubble.update();
                bubble.draw();
            });

            fish.update();
            fish.draw();

            drawUI();

            requestAnimationFrame(animate);
        }

        // Start the food spawning cycle and animation
        scheduleNextFoodBubble();
        animate();

    </script>
</body>
</html>

